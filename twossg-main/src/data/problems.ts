import { Problem } from '@/types/game';

export const problems: Problem[] = [
  // ===== LEVEL 1: EASY - Array Basics =====
  {
    id: 1,
    level: 1,
    title: "Find Max Value",
    story: "Bạn đang làm việc tại một công ty giao hàng. Hệ thống cần tìm đơn hàng có giá trị lớn nhất trong danh sách để ưu tiên xử lý trước.",
    description: "Tìm giá trị lớn nhất trong một mảng số nguyên",
    skill: "Array",
    difficulty: "Easy",
    input: "Một mảng số nguyên nums với độ dài n (1 ≤ n ≤ 10^5)",
    output: "Số nguyên lớn nhất trong mảng",
    examples: [
      { input: "[3, 1, 4, 1, 5, 9, 2, 6]", output: "9", explanation: "9 là số lớn nhất trong mảng" },
      { input: "[-1, -5, -2]", output: "-1", explanation: "Với mảng toàn số âm, -1 là lớn nhất" }
    ],
    hints: ["Bắt đầu với việc giả sử phần tử đầu tiên là lớn nhất", "Duyệt qua từng phần tử và so sánh với giá trị lớn nhất hiện tại"],
    interviewQuestions: ["Vì sao bạn chọn cách tiếp cận này?", "Độ phức tạp thời gian và không gian của thuật toán là gì?", "Nếu mảng rỗng thì sao?"],
    testCases: [{ input: "[1, 2, 3, 4, 5]", output: "5" }, { input: "[5, 4, 3, 2, 1]", output: "5" }],
    theoryQuestions: [{ question: "Độ phức tạp thời gian của việc tìm max trong mảng là gì?", options: ["O(1)", "O(log n)", "O(n)", "O(n²)"], correct: 2, explanation: "Phải duyệt qua tất cả phần tử ít nhất một lần" }]
  },
  {
    id: 2,
    level: 1,
    title: "Sum of Array",
    story: "Hệ thống kế toán cần tính tổng doanh thu hàng ngày từ danh sách các giao dịch.",
    description: "Tính tổng tất cả các phần tử trong mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng số nguyên nums",
    output: "Tổng các phần tử",
    examples: [{ input: "[1, 2, 3, 4, 5]", output: "15", explanation: "1+2+3+4+5 = 15" }],
    hints: ["Khởi tạo biến sum = 0", "Duyệt và cộng dồn"],
    interviewQuestions: ["Có cách nào tính tổng mà không dùng vòng lặp?", "Nếu số quá lớn thì sao?"],
    testCases: [{ input: "[10, 20, 30]", output: "60" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(1)", "O(n)", "O(n²)", "O(log n)"], correct: 1, explanation: "Duyệt qua n phần tử một lần" }]
  },
  {
    id: 3,
    level: 1,
    title: "Find Min Value",
    story: "Tìm sản phẩm có giá thấp nhất để hiển thị trong mục 'Ưu đãi hôm nay'.",
    description: "Tìm giá trị nhỏ nhất trong mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng số nguyên nums",
    output: "Số nhỏ nhất",
    examples: [{ input: "[3, 1, 4, 1, 5]", output: "1" }],
    hints: ["Tương tự tìm max nhưng so sánh ngược lại"],
    interviewQuestions: ["Làm sao tìm cả min và max trong một lần duyệt?"],
    testCases: [{ input: "[7, 2, 9, 1, 5]", output: "1" }],
    theoryQuestions: [{ question: "Có thể tìm min trong O(log n) không?", options: ["Có, luôn luôn", "Chỉ khi mảng sorted", "Không bao giờ", "Chỉ với heap"], correct: 1, explanation: "Binary search chỉ áp dụng cho mảng đã sắp xếp" }]
  },
  {
    id: 4,
    level: 1,
    title: "Count Even Numbers",
    story: "Hệ thống phân loại cần đếm số sản phẩm có mã chẵn để xử lý riêng.",
    description: "Đếm số phần tử chẵn trong mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng số nguyên",
    output: "Số lượng số chẵn",
    examples: [{ input: "[1, 2, 3, 4, 5, 6]", output: "3", explanation: "2, 4, 6 là số chẵn" }],
    hints: ["Số chẵn chia 2 dư 0", "Dùng toán tử %"],
    interviewQuestions: ["Nếu cần đếm cả chẵn và lẻ thì sao?"],
    testCases: [{ input: "[1, 3, 5, 7]", output: "0" }],
    theoryQuestions: [{ question: "Cách nào kiểm tra số chẵn nhanh nhất?", options: ["n / 2 == 0", "n % 2 == 0", "n & 1 == 0", "Cả B và C"], correct: 3, explanation: "Bitwise AND nhanh hơn modulo" }]
  },
  {
    id: 5,
    level: 1,
    title: "Reverse Array",
    story: "Hiển thị bài viết theo thứ tự mới nhất trước (đảo ngược danh sách).",
    description: "Đảo ngược thứ tự mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng nums",
    output: "Mảng đã đảo ngược",
    examples: [{ input: "[1, 2, 3, 4, 5]", output: "[5, 4, 3, 2, 1]" }],
    hints: ["Two pointer: đầu và cuối", "Swap cho đến khi gặp nhau"],
    interviewQuestions: ["Làm in-place hay tạo mảng mới?", "Space complexity là gì?"],
    testCases: [{ input: "[1, 2]", output: "[2, 1]" }],
    theoryQuestions: [{ question: "In-place reverse có space complexity là?", options: ["O(n)", "O(log n)", "O(1)", "O(n²)"], correct: 2, explanation: "Chỉ dùng vài biến tạm" }]
  },
  {
    id: 6,
    level: 1,
    title: "Check Sorted Array",
    story: "Kiểm tra xem danh sách đánh giá đã được sắp xếp theo rating chưa.",
    description: "Kiểm tra mảng có tăng dần không",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng số nguyên",
    output: "true/false",
    examples: [{ input: "[1, 2, 3, 4]", output: "true" }, { input: "[1, 3, 2, 4]", output: "false" }],
    hints: ["So sánh từng cặp liên tiếp"],
    interviewQuestions: ["Có cần kiểm tra hết mảng không?"],
    testCases: [{ input: "[5, 4, 3]", output: "false" }],
    theoryQuestions: [{ question: "Best case khi nào?", options: ["Khi sorted", "Khi phần tử đầu > phần tử 2", "Khi mảng rỗng", "Không có best case"], correct: 1, explanation: "Phát hiện sớm nếu có cặp không tăng" }]
  },
  {
    id: 7,
    level: 1,
    title: "Find Second Max",
    story: "Tìm runner-up trong cuộc thi (người có điểm cao thứ 2).",
    description: "Tìm số lớn thứ hai trong mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng ít nhất 2 phần tử distinct",
    output: "Số lớn thứ 2",
    examples: [{ input: "[1, 5, 3, 9, 7]", output: "7" }],
    hints: ["Track cả max và secondMax", "Cập nhật cả hai khi tìm thấy max mới"],
    interviewQuestions: ["Nếu có nhiều phần tử bằng max thì sao?"],
    testCases: [{ input: "[10, 10, 9]", output: "9" }],
    theoryQuestions: [{ question: "Có thể giải trong O(n) không?", options: ["Không", "Có", "Chỉ O(n log n)", "Chỉ O(n²)"], correct: 1, explanation: "Duyệt một lần, track 2 giá trị" }]
  },
  {
    id: 8,
    level: 1,
    title: "Average of Array",
    story: "Tính điểm trung bình của sinh viên.",
    description: "Tính giá trị trung bình của mảng",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng số",
    output: "Trung bình cộng",
    examples: [{ input: "[10, 20, 30]", output: "20" }],
    hints: ["Tổng chia cho số phần tử"],
    interviewQuestions: ["Làm sao tránh overflow khi tính tổng?"],
    testCases: [{ input: "[5, 5, 5]", output: "5" }],
    theoryQuestions: [{ question: "Để tránh overflow, nên?", options: ["Chia trước khi cộng", "Dùng BigInt", "Chia sau cùng", "Không cần lo"], correct: 0, explanation: "Có thể tính mean = mean + (x - mean) / n" }]
  },
  {
    id: 9,
    level: 1,
    title: "Remove Duplicates",
    story: "Loại bỏ email trùng lặp trong danh sách gửi newsletter.",
    description: "Trả về mảng chỉ chứa các phần tử duy nhất",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng có thể có trùng lặp",
    output: "Mảng không trùng",
    examples: [{ input: "[1, 2, 2, 3, 3, 3]", output: "[1, 2, 3]" }],
    hints: ["Dùng Set", "Hoặc sort rồi so sánh liên tiếp"],
    interviewQuestions: ["Set vs sort approach - trade-off?"],
    testCases: [{ input: "[1, 1, 1]", output: "[1]" }],
    theoryQuestions: [{ question: "Set approach có time complexity?", options: ["O(n)", "O(n log n)", "O(n²)", "O(1)"], correct: 0, explanation: "Set insert và lookup trung bình O(1)" }]
  },
  {
    id: 10,
    level: 1,
    title: "Contains Duplicate",
    story: "Kiểm tra xem có mã sản phẩm bị trùng không.",
    description: "Kiểm tra mảng có phần tử trùng lặp không",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng nums",
    output: "true nếu có trùng, false nếu không",
    examples: [{ input: "[1, 2, 3, 1]", output: "true" }, { input: "[1, 2, 3, 4]", output: "false" }],
    hints: ["Dùng Set để track đã gặp"],
    interviewQuestions: ["Nếu không dùng extra space thì sao?"],
    testCases: [{ input: "[1]", output: "false" }],
    theoryQuestions: [{ question: "Sorting approach có complexity?", options: ["O(n)", "O(n log n)", "O(n²)", "O(1)"], correct: 1, explanation: "Sort O(n log n), sau đó check O(n)" }]
  },

  // ===== LEVEL 2: EASY+ - String & Hash =====
  {
    id: 11,
    level: 2,
    title: "Two Sum",
    story: "Tìm 2 sản phẩm có tổng giá đúng bằng ngân sách để gợi ý combo deal!",
    description: "Tìm hai số trong mảng có tổng bằng target",
    skill: "Hash Table",
    difficulty: "Easy",
    input: "Mảng nums và số target",
    output: "Chỉ số của hai số",
    examples: [{ input: "nums = [2, 7, 11, 15], target = 9", output: "[0, 1]", explanation: "2 + 7 = 9" }],
    hints: ["Dùng Hash Map lưu số đã gặp", "Check target - nums[i] có trong map không"],
    interviewQuestions: ["Trade-off giữa time và space?", "Nếu có nhiều cặp thì sao?"],
    testCases: [{ input: "nums = [3, 2, 4], target = 6", output: "[1, 2]" }],
    theoryQuestions: [{ question: "Hash Map giảm complexity từ O(n²) xuống?", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], correct: 2, explanation: "Lookup O(1), duyệt một lần O(n)" }]
  },
  {
    id: 12,
    level: 2,
    title: "Valid Parentheses",
    story: "Kiểm tra syntax - các cặp ngoặc có khớp không trong IDE.",
    description: "Kiểm tra chuỗi ngoặc có hợp lệ không",
    skill: "Stack",
    difficulty: "Easy",
    input: "Chuỗi chứa '(', ')', '{', '}', '[', ']'",
    output: "true/false",
    examples: [{ input: '"()[]{}"', output: "true" }, { input: '"(]"', output: "false" }],
    hints: ["Dùng Stack - LIFO", "Ngoặc mở: push, ngoặc đóng: check và pop"],
    interviewQuestions: ["Tại sao Stack phù hợp?", "Edge cases?"],
    testCases: [{ input: '"{[]}"', output: "true" }],
    theoryQuestions: [{ question: "Stack hoạt động theo?", options: ["FIFO", "LIFO", "Random", "Priority"], correct: 1, explanation: "Last In First Out" }]
  },
  {
    id: 13,
    level: 2,
    title: "Reverse String",
    story: "Tạo hiệu ứng gương cho tên người dùng.",
    description: "Đảo ngược chuỗi ký tự",
    skill: "String",
    difficulty: "Easy",
    input: "Chuỗi s",
    output: "Chuỗi đảo ngược",
    examples: [{ input: '"hello"', output: '"olleh"' }],
    hints: ["Two pointer", "Hoặc dùng built-in reverse"],
    interviewQuestions: ["In-place có được không?", "Unicode handling?"],
    testCases: [{ input: '"ab"', output: '"ba"' }],
    theoryQuestions: [{ question: "In-place reverse string có space?", options: ["O(n)", "O(1)", "O(log n)", "O(n²)"], correct: 1, explanation: "Chỉ swap tại chỗ" }]
  },
  {
    id: 14,
    level: 2,
    title: "Palindrome Check",
    story: "Kiểm tra username có đọc xuôi ngược như nhau không.",
    description: "Kiểm tra chuỗi có phải palindrome không",
    skill: "String",
    difficulty: "Easy",
    input: "Chuỗi s",
    output: "true nếu palindrome",
    examples: [{ input: '"racecar"', output: "true" }, { input: '"hello"', output: "false" }],
    hints: ["So sánh với reverse", "Hoặc two pointer từ 2 đầu"],
    interviewQuestions: ["Có cần tạo chuỗi mới không?", "Case insensitive?"],
    testCases: [{ input: '"a"', output: "true" }],
    theoryQuestions: [{ question: "Two pointer approach có space?", options: ["O(n)", "O(1)", "O(n/2)", "O(log n)"], correct: 1, explanation: "Không tạo chuỗi mới" }]
  },
  {
    id: 15,
    level: 2,
    title: "Anagram Check",
    story: "Kiểm tra hai từ có phải đảo chữ của nhau không (game Wordle).",
    description: "Kiểm tra s và t có phải anagram không",
    skill: "Hash Table",
    difficulty: "Easy",
    input: "Hai chuỗi s và t",
    output: "true nếu là anagram",
    examples: [{ input: 's = "anagram", t = "nagaram"', output: "true" }],
    hints: ["Đếm tần suất ký tự", "Hoặc sort cả hai rồi so sánh"],
    interviewQuestions: ["Counting vs sorting?", "Unicode?"],
    testCases: [{ input: 's = "rat", t = "car"', output: "false" }],
    theoryQuestions: [{ question: "Sorting approach có complexity?", options: ["O(n)", "O(n log n)", "O(n²)", "O(1)"], correct: 1, explanation: "Sort chi phối" }]
  },
  {
    id: 16,
    level: 2,
    title: "First Unique Character",
    story: "Tìm ký tự đầu tiên không lặp để làm avatar mặc định.",
    description: "Tìm index ký tự đầu tiên không lặp trong chuỗi",
    skill: "Hash Table",
    difficulty: "Easy",
    input: "Chuỗi s",
    output: "Index hoặc -1",
    examples: [{ input: '"leetcode"', output: "0", explanation: "'l' không lặp" }],
    hints: ["Đếm frequency trước", "Duyệt lại tìm char có count = 1"],
    interviewQuestions: ["Có thể làm một lần duyệt không?"],
    testCases: [{ input: '"aabb"', output: "-1" }],
    theoryQuestions: [{ question: "Cần bao nhiêu lần duyệt?", options: ["1", "2", "3", "n"], correct: 1, explanation: "1 để đếm, 1 để tìm" }]
  },
  {
    id: 17,
    level: 2,
    title: "Count Words",
    story: "Đếm số từ trong bài viết blog.",
    description: "Đếm số từ trong chuỗi (phân tách bởi space)",
    skill: "String",
    difficulty: "Easy",
    input: "Chuỗi s",
    output: "Số từ",
    examples: [{ input: '"Hello World"', output: "2" }],
    hints: ["Split by space", "Xử lý multiple spaces"],
    interviewQuestions: ["Làm sao xử lý spaces thừa?"],
    testCases: [{ input: '"  a  b  "', output: "2" }],
    theoryQuestions: [{ question: "Regex split có complexity?", options: ["O(1)", "O(n)", "O(n²)", "O(log n)"], correct: 1, explanation: "Duyệt qua chuỗi một lần" }]
  },
  {
    id: 18,
    level: 2,
    title: "Longest Common Prefix",
    story: "Tìm tiền tố chung của tên file để gom nhóm.",
    description: "Tìm longest common prefix trong array strings",
    skill: "String",
    difficulty: "Easy",
    input: "Mảng strings",
    output: "Longest common prefix",
    examples: [{ input: '["flower","flow","flight"]', output: '"fl"' }],
    hints: ["So sánh ký tự tại từng vị trí", "Dừng khi khác nhau"],
    interviewQuestions: ["Có thể dùng binary search không?"],
    testCases: [{ input: '["dog","racecar","car"]', output: '""' }],
    theoryQuestions: [{ question: "Worst case complexity?", options: ["O(n)", "O(S)", "O(n²)", "O(S*n)"], correct: 1, explanation: "S là tổng độ dài tất cả strings" }]
  },
  {
    id: 19,
    level: 2,
    title: "Merge Sorted Arrays",
    story: "Gộp 2 danh sách điểm đã sắp xếp thành một.",
    description: "Merge 2 mảng sorted thành 1 mảng sorted",
    skill: "Array",
    difficulty: "Easy",
    input: "Hai mảng sorted nums1 và nums2",
    output: "Mảng merged",
    examples: [{ input: "nums1 = [1,3,5], nums2 = [2,4,6]", output: "[1,2,3,4,5,6]" }],
    hints: ["Two pointer", "So sánh và thêm số nhỏ hơn"],
    interviewQuestions: ["Có thể merge in-place không?"],
    testCases: [{ input: "nums1 = [1], nums2 = [2]", output: "[1,2]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(m+n)", "O(n log n)", "O(mn)"], correct: 1, explanation: "Mỗi phần tử được xử lý một lần" }]
  },
  {
    id: 20,
    level: 2,
    title: "Move Zeroes",
    story: "Di chuyển các order đã hủy (giá trị 0) về cuối danh sách.",
    description: "Di chuyển tất cả 0 về cuối mảng, giữ thứ tự các số khác",
    skill: "Array",
    difficulty: "Easy",
    input: "Mảng nums",
    output: "Mảng với 0 ở cuối",
    examples: [{ input: "[0,1,0,3,12]", output: "[1,3,12,0,0]" }],
    hints: ["Two pointer: insertPos và i", "Swap hoặc overwrite"],
    interviewQuestions: ["Minimize số operations?"],
    testCases: [{ input: "[0,0,1]", output: "[1,0,0]" }],
    theoryQuestions: [{ question: "Minimum swaps approach có bao nhiêu swap?", options: ["n", "Số phần tử != 0", "Số 0", "n/2"], correct: 1, explanation: "Chỉ swap khi gặp số khác 0" }]
  },

  // ===== LEVEL 3: EASY++ - Linked List & Binary Search =====
  {
    id: 21,
    level: 3,
    title: "Reverse Linked List",
    story: "Implement Undo cho app note-taking bằng cách đảo ngược linked list.",
    description: "Đảo ngược singly linked list",
    skill: "Linked List",
    difficulty: "Easy",
    input: "Head của linked list",
    output: "Head của list đã đảo ngược",
    examples: [{ input: "[1,2,3,4,5]", output: "[5,4,3,2,1]" }],
    hints: ["3 pointer: prev, curr, next", "Hoặc đệ quy"],
    interviewQuestions: ["Iterative vs recursive?", "Space complexity?"],
    testCases: [{ input: "[1]", output: "[1]" }],
    theoryQuestions: [{ question: "Recursive có space complexity?", options: ["O(1)", "O(log n)", "O(n)", "O(n²)"], correct: 2, explanation: "Call stack n levels" }]
  },
  {
    id: 22,
    level: 3,
    title: "Binary Search",
    story: "Tìm sách trong thư viện 1 triệu cuốn đã sắp xếp theo alphabet.",
    description: "Tìm vị trí target trong mảng sorted",
    skill: "Binary Search",
    difficulty: "Easy",
    input: "Mảng sorted nums và target",
    output: "Index hoặc -1",
    examples: [{ input: "nums = [-1,0,3,5,9,12], target = 9", output: "4" }],
    hints: ["Chia đôi range mỗi bước", "So sánh với mid"],
    interviewQuestions: ["Tại sao O(log n)?", "mid = (left + right) / 2 có vấn đề gì?"],
    testCases: [{ input: "nums = [1], target = 1", output: "0" }],
    theoryQuestions: [{ question: "Cách tính mid tránh overflow?", options: ["(left+right)/2", "left+(right-left)/2", "right-left/2", "(left*right)/2"], correct: 1, explanation: "Tránh left+right vượt MAX_INT" }]
  },
  {
    id: 23,
    level: 3,
    title: "Merge Two Sorted Lists",
    story: "Gộp 2 playlist nhạc đã sắp xếp theo rating.",
    description: "Merge hai linked list sorted thành một",
    skill: "Linked List",
    difficulty: "Easy",
    input: "Hai head của sorted lists",
    output: "Head của merged list",
    examples: [{ input: "l1=[1,2,4], l2=[1,3,4]", output: "[1,1,2,3,4,4]" }],
    hints: ["Dummy head", "So sánh và link node nhỏ hơn"],
    interviewQuestions: ["Tại sao dùng dummy node?", "Recursive có được không?"],
    testCases: [{ input: "l1=[], l2=[0]", output: "[0]" }],
    theoryQuestions: [{ question: "Space complexity iterative?", options: ["O(n+m)", "O(1)", "O(n)", "O(m)"], correct: 1, explanation: "Chỉ dùng vài pointer" }]
  },
  {
    id: 24,
    level: 3,
    title: "Middle of Linked List",
    story: "Tìm phần tử giữa để chia đôi playlist.",
    description: "Tìm node giữa của linked list",
    skill: "Linked List",
    difficulty: "Easy",
    input: "Head của list",
    output: "Node giữa",
    examples: [{ input: "[1,2,3,4,5]", output: "3" }, { input: "[1,2,3,4,5,6]", output: "4" }],
    hints: ["Slow và fast pointer", "Fast đi gấp đôi slow"],
    interviewQuestions: ["Nếu có 2 node giữa thì chọn cái nào?"],
    testCases: [{ input: "[1]", output: "1" }],
    theoryQuestions: [{ question: "Two pointer technique có tên khác?", options: ["Binary search", "Tortoise and Hare", "Divide conquer", "Sliding window"], correct: 1, explanation: "Slow như rùa, fast như thỏ" }]
  },
  {
    id: 25,
    level: 3,
    title: "Linked List Cycle",
    story: "Phát hiện infinite loop trong workflow.",
    description: "Kiểm tra linked list có cycle không",
    skill: "Linked List",
    difficulty: "Easy",
    input: "Head của list",
    output: "true nếu có cycle",
    examples: [{ input: "[3,2,0,-4] với tail connect node index 1", output: "true" }],
    hints: ["Floyd's algorithm", "Fast và slow sẽ gặp nhau nếu có cycle"],
    interviewQuestions: ["Tại sao sẽ gặp nhau?", "Tìm điểm bắt đầu cycle?"],
    testCases: [{ input: "[1,2] no cycle", output: "false" }],
    theoryQuestions: [{ question: "Space complexity của Floyd's?", options: ["O(n)", "O(1)", "O(log n)", "O(n²)"], correct: 1, explanation: "Chỉ dùng 2 pointer" }]
  },
  {
    id: 26,
    level: 3,
    title: "Remove Nth Node From End",
    story: "Xóa task thứ n từ cuối todo list.",
    description: "Xóa node thứ n từ cuối linked list",
    skill: "Linked List",
    difficulty: "Medium",
    input: "Head và n",
    output: "Head sau khi xóa",
    examples: [{ input: "[1,2,3,4,5], n = 2", output: "[1,2,3,5]" }],
    hints: ["Two pointer cách nhau n bước", "Dummy head cho edge case"],
    interviewQuestions: ["One pass có được không?"],
    testCases: [{ input: "[1], n = 1", output: "[]" }],
    theoryQuestions: [{ question: "Tại sao cần dummy node?", options: ["Đẹp code", "Xử lý xóa head", "Tối ưu time", "Không cần"], correct: 1, explanation: "Khi n = length, cần xóa head" }]
  },
  {
    id: 27,
    level: 3,
    title: "Search Insert Position",
    story: "Tìm vị trí chèn sản phẩm mới vào danh sách sorted.",
    description: "Tìm index để insert target vào sorted array",
    skill: "Binary Search",
    difficulty: "Easy",
    input: "Sorted array và target",
    output: "Index để insert",
    examples: [{ input: "[1,3,5,6], target = 5", output: "2" }, { input: "[1,3,5,6], target = 2", output: "1" }],
    hints: ["Binary search biến thể", "Trả về left khi không tìm thấy"],
    interviewQuestions: ["Khác gì với binary search thường?"],
    testCases: [{ input: "[1,3], target = 0", output: "0" }],
    theoryQuestions: [{ question: "Khi target không có, trả về?", options: ["right", "left", "-1", "mid"], correct: 1, explanation: "left là vị trí insert" }]
  },
  {
    id: 28,
    level: 3,
    title: "First Bad Version",
    story: "Tìm commit đầu tiên gây bug trong version control.",
    description: "Tìm version đầu tiên bị bad (API isBadVersion)",
    skill: "Binary Search",
    difficulty: "Easy",
    input: "n versions, isBadVersion API",
    output: "First bad version number",
    examples: [{ input: "n = 5, bad = 4", output: "4" }],
    hints: ["Binary search", "isBadVersion(mid) true -> tìm bên trái"],
    interviewQuestions: ["Minimize API calls?"],
    testCases: [{ input: "n = 1, bad = 1", output: "1" }],
    theoryQuestions: [{ question: "Số API calls tối đa?", options: ["n", "log n", "n/2", "2n"], correct: 1, explanation: "Binary search chỉ gọi O(log n) lần" }]
  },
  {
    id: 29,
    level: 3,
    title: "Sqrt(x)",
    story: "Tính căn bậc 2 cho ứng dụng calculator.",
    description: "Tính căn bậc 2 của x (làm tròn xuống)",
    skill: "Binary Search",
    difficulty: "Easy",
    input: "Số nguyên x >= 0",
    output: "floor(sqrt(x))",
    examples: [{ input: "x = 8", output: "2", explanation: "sqrt(8) ≈ 2.83, floor = 2" }],
    hints: ["Binary search từ 0 đến x", "mid*mid <= x thì ans = mid"],
    interviewQuestions: ["Overflow khi mid*mid?", "Newton's method?"],
    testCases: [{ input: "x = 4", output: "2" }],
    theoryQuestions: [{ question: "Cách nào tránh overflow mid*mid?", options: ["mid <= x/mid", "Dùng long", "Cả hai đều được", "Không cần"], correct: 2, explanation: "Chia thay vì nhân, hoặc dùng kiểu lớn hơn" }]
  },
  {
    id: 30,
    level: 3,
    title: "Valid Perfect Square",
    story: "Kiểm tra số có phải perfect square để hiển thị grid đẹp.",
    description: "Kiểm tra x có phải số chính phương không",
    skill: "Binary Search",
    difficulty: "Easy",
    input: "Số nguyên dương x",
    output: "true nếu là perfect square",
    examples: [{ input: "x = 16", output: "true" }, { input: "x = 14", output: "false" }],
    hints: ["Binary search tìm số có bình phương = x"],
    interviewQuestions: ["Có cách O(sqrt(n)) không dùng nhân?"],
    testCases: [{ input: "x = 1", output: "true" }],
    theoryQuestions: [{ question: "1+3+5+...+(2n-1) = ?", options: ["n", "2n", "n²", "n(n+1)/2"], correct: 2, explanation: "Tổng n số lẻ đầu = n², có thể dùng để check" }]
  },

  // ===== LEVEL 4: MEDIUM - DP & Tree =====
  {
    id: 31,
    level: 4,
    title: "Climbing Stairs",
    story: "Đếm số cách leo n bậc thang (1 hoặc 2 bậc mỗi bước).",
    description: "Số cách khác nhau để leo n bậc",
    skill: "Dynamic Programming",
    difficulty: "Easy",
    input: "n (1 ≤ n ≤ 45)",
    output: "Số cách",
    examples: [{ input: "n = 3", output: "3", explanation: "(1+1+1), (1+2), (2+1)" }],
    hints: ["f(n) = f(n-1) + f(n-2)", "Giống Fibonacci"],
    interviewQuestions: ["Tối ưu space từ O(n) xuống O(1)?", "Nếu có thể nhảy 3 bước?"],
    testCases: [{ input: "n = 5", output: "8" }],
    theoryQuestions: [{ question: "Recursion không memo có complexity?", options: ["O(n)", "O(n²)", "O(2^n)", "O(log n)"], correct: 2, explanation: "Mỗi call tạo 2 call mới" }]
  },
  {
    id: 32,
    level: 4,
    title: "House Robber",
    story: "Tên trộm cần tối đa hóa tiền mà không cướp 2 nhà liền kề.",
    description: "Max sum với điều kiện không chọn 2 phần tử liên tiếp",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums (giá trị mỗi nhà)",
    output: "Maximum sum",
    examples: [{ input: "[1,2,3,1]", output: "4", explanation: "Chọn nhà 1 và 3: 1+3=4" }],
    hints: ["dp[i] = max(dp[i-1], dp[i-2] + nums[i])"],
    interviewQuestions: ["Tại sao công thức này đúng?", "Circular houses?"],
    testCases: [{ input: "[2,7,9,3,1]", output: "12" }],
    theoryQuestions: [{ question: "Bài này thuộc loại DP nào?", options: ["0/1 Knapsack", "Unbounded Knapsack", "LCS", "LIS"], correct: 0, explanation: "Chọn hoặc không chọn mỗi phần tử" }]
  },
  {
    id: 33,
    level: 4,
    title: "Maximum Subarray",
    story: "Tìm khoảng thời gian có profit cao nhất trong giao dịch.",
    description: "Tìm subarray có tổng lớn nhất",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums",
    output: "Maximum sum",
    examples: [{ input: "[-2,1,-3,4,-1,2,1,-5,4]", output: "6", explanation: "[4,-1,2,1] = 6" }],
    hints: ["Kadane's algorithm", "currentMax = max(nums[i], currentMax + nums[i])"],
    interviewQuestions: ["Giải thích Kadane's?", "Tìm indices của subarray?"],
    testCases: [{ input: "[1]", output: "1" }],
    theoryQuestions: [{ question: "Kadane's có complexity?", options: ["O(n²)", "O(n log n)", "O(n)", "O(1)"], correct: 2, explanation: "Một lần duyệt" }]
  },
  {
    id: 34,
    level: 4,
    title: "Coin Change",
    story: "Tìm số coin ít nhất để đổi amount tiền.",
    description: "Minimum coins để đạt amount",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Coins array và amount",
    output: "Min coins hoặc -1",
    examples: [{ input: "coins = [1,2,5], amount = 11", output: "3", explanation: "5+5+1" }],
    hints: ["dp[i] = min(dp[i], dp[i-coin] + 1)"],
    interviewQuestions: ["Bottom-up vs top-down?", "Greedy tại sao không work?"],
    testCases: [{ input: "coins = [2], amount = 3", output: "-1" }],
    theoryQuestions: [{ question: "Bài này thuộc loại DP nào?", options: ["0/1 Knapsack", "Unbounded Knapsack", "LCS", "Matrix Chain"], correct: 1, explanation: "Mỗi coin có thể dùng nhiều lần" }]
  },
  {
    id: 35,
    level: 4,
    title: "Longest Increasing Subsequence",
    story: "Tìm chuỗi ngày doanh thu tăng dài nhất.",
    description: "Độ dài longest increasing subsequence",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums",
    output: "Độ dài LIS",
    examples: [{ input: "[10,9,2,5,3,7,101,18]", output: "4", explanation: "[2,3,7,101]" }],
    hints: ["DP: dp[i] = max(dp[j]+1) với j < i và nums[j] < nums[i]", "Binary search có thể tối ưu O(n log n)"],
    interviewQuestions: ["O(n²) vs O(n log n)?"],
    testCases: [{ input: "[7,7,7,7]", output: "1" }],
    theoryQuestions: [{ question: "DP solution có complexity?", options: ["O(n)", "O(n log n)", "O(n²)", "O(2^n)"], correct: 2, explanation: "2 nested loops" }]
  },
  {
    id: 36,
    level: 4,
    title: "Binary Tree Inorder Traversal",
    story: "Duyệt cây BST để in ra các phần tử theo thứ tự tăng dần.",
    description: "Inorder traversal của binary tree",
    skill: "Tree",
    difficulty: "Easy",
    input: "Root của tree",
    output: "List các giá trị inorder",
    examples: [{ input: "[1,null,2,3]", output: "[1,3,2]" }],
    hints: ["Left -> Root -> Right", "Đệ quy hoặc stack"],
    interviewQuestions: ["Iterative solution?", "Morris traversal?"],
    testCases: [{ input: "[]", output: "[]" }],
    theoryQuestions: [{ question: "Inorder của BST cho ra?", options: ["Random order", "Sorted order", "Reverse order", "Level order"], correct: 1, explanation: "BST inorder = sorted" }]
  },
  {
    id: 37,
    level: 4,
    title: "Maximum Depth of Binary Tree",
    story: "Tính độ sâu của cây thư mục.",
    description: "Độ sâu tối đa của binary tree",
    skill: "Tree",
    difficulty: "Easy",
    input: "Root",
    output: "Maximum depth",
    examples: [{ input: "[3,9,20,null,null,15,7]", output: "3" }],
    hints: ["Đệ quy: 1 + max(left, right)", "BFS đếm levels"],
    interviewQuestions: ["DFS vs BFS approach?"],
    testCases: [{ input: "[]", output: "0" }],
    theoryQuestions: [{ question: "Space complexity của DFS?", options: ["O(1)", "O(log n)", "O(n)", "O(h)"], correct: 3, explanation: "h là chiều cao cây (worst O(n))" }]
  },
  {
    id: 38,
    level: 4,
    title: "Same Tree",
    story: "Kiểm tra 2 cấu trúc folder có giống nhau không.",
    description: "Kiểm tra 2 binary tree có giống nhau không",
    skill: "Tree",
    difficulty: "Easy",
    input: "Hai root p và q",
    output: "true/false",
    examples: [{ input: "p = [1,2,3], q = [1,2,3]", output: "true" }],
    hints: ["Đệ quy so sánh value và cả hai subtrees"],
    interviewQuestions: ["Iterative với queue?"],
    testCases: [{ input: "p = [1,2], q = [1,null,2]", output: "false" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(min(n,m))", "O(n+m)", "O(n*m)"], correct: 1, explanation: "Dừng sớm khi phát hiện khác" }]
  },
  {
    id: 39,
    level: 4,
    title: "Symmetric Tree",
    story: "Kiểm tra cây có đối xứng qua trục giữa không.",
    description: "Kiểm tra tree có mirror symmetry không",
    skill: "Tree",
    difficulty: "Easy",
    input: "Root",
    output: "true/false",
    examples: [{ input: "[1,2,2,3,4,4,3]", output: "true" }],
    hints: ["Compare left.left với right.right", "left.right với right.left"],
    interviewQuestions: ["Iterative solution?"],
    testCases: [{ input: "[1,2,2,null,3,null,3]", output: "false" }],
    theoryQuestions: [{ question: "Cần so sánh bao nhiêu cặp node?", options: ["n", "n/2", "log n", "n²"], correct: 1, explanation: "Mỗi node trái so với node phải tương ứng" }]
  },
  {
    id: 40,
    level: 4,
    title: "Invert Binary Tree",
    story: "Tạo mirror image của tree cho UI animation.",
    description: "Đảo ngược binary tree (swap left và right)",
    skill: "Tree",
    difficulty: "Easy",
    input: "Root",
    output: "Root của inverted tree",
    examples: [{ input: "[4,2,7,1,3,6,9]", output: "[4,7,2,9,6,3,1]" }],
    hints: ["Đệ quy swap children", "BFS với queue cũng được"],
    interviewQuestions: ["Tại sao bài này từng nổi tiếng?"],
    testCases: [{ input: "[2,1,3]", output: "[2,3,1]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(log n)", "O(n)", "O(n²)", "O(1)"], correct: 1, explanation: "Visit mỗi node một lần" }]
  },

  // ===== LEVEL 5: MEDIUM - Sliding Window & More DP =====
  {
    id: 41,
    level: 5,
    title: "Longest Substring Without Repeating",
    story: "Tìm đoạn dài nhất không lặp ký tự trong password strength checker.",
    description: "Độ dài substring dài nhất không có ký tự trùng",
    skill: "Sliding Window",
    difficulty: "Medium",
    input: "Chuỗi s",
    output: "Độ dài",
    examples: [{ input: '"abcabcbb"', output: "3", explanation: '"abc"' }],
    hints: ["Sliding window", "Set/Map track ký tự trong window"],
    interviewQuestions: ["Tại sao không cần nested loop?"],
    testCases: [{ input: '"bbbbb"', output: "1" }],
    theoryQuestions: [{ question: "Sliding Window phù hợp với?", options: ["Tree problems", "Contiguous subarray/substring", "Graph", "Sorting"], correct: 1, explanation: "Tối ưu cho bài substring/subarray liên tục" }]
  },
  {
    id: 42,
    level: 5,
    title: "Maximum Product Subarray",
    story: "Tìm khoảng thời gian có product rating cao nhất.",
    description: "Subarray có tích lớn nhất",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums",
    output: "Maximum product",
    examples: [{ input: "[2,3,-2,4]", output: "6", explanation: "[2,3] = 6" }],
    hints: ["Track cả max và min (số âm * âm = dương)", "Swap max/min khi gặp số âm"],
    interviewQuestions: ["Tại sao cần track min?", "So với max sum subarray?"],
    testCases: [{ input: "[-2,0,-1]", output: "0" }],
    theoryQuestions: [{ question: "Tại sao cần theo dõi minimum?", options: ["Không cần", "Số âm * âm = dương", "Để tính average", "Để tìm subarray"], correct: 1, explanation: "Min âm * số âm mới có thể thành max dương" }]
  },
  {
    id: 43,
    level: 5,
    title: "Container With Most Water",
    story: "Tìm 2 bức tường để chứa nhiều nước nhất.",
    description: "Maximum area giữa 2 lines",
    skill: "Two Pointers",
    difficulty: "Medium",
    input: "Array height của các lines",
    output: "Maximum area",
    examples: [{ input: "[1,8,6,2,5,4,8,3,7]", output: "49" }],
    hints: ["Two pointer từ 2 đầu", "Di chuyển pointer có height nhỏ hơn"],
    interviewQuestions: ["Tại sao di chuyển pointer nhỏ hơn?"],
    testCases: [{ input: "[1,1]", output: "1" }],
    theoryQuestions: [{ question: "Greedy choice ở đây là?", options: ["Chọn max height", "Di chuyển min height", "Random", "Từ giữa ra"], correct: 1, explanation: "Giữ height lớn, hy vọng tìm height lớn hơn" }]
  },
  {
    id: 44,
    level: 5,
    title: "3Sum",
    story: "Tìm 3 sản phẩm có tổng giá = 0 (combo discount).",
    description: "Tìm tất cả triplets có tổng = 0",
    skill: "Two Pointers",
    difficulty: "Medium",
    input: "Mảng nums",
    output: "List các triplets",
    examples: [{ input: "[-1,0,1,2,-1,-4]", output: "[[-1,-1,2],[-1,0,1]]" }],
    hints: ["Sort trước", "Fix 1 số, two sum cho 2 số còn lại"],
    interviewQuestions: ["Làm sao tránh duplicate?", "Time complexity?"],
    testCases: [{ input: "[0,0,0]", output: "[[0,0,0]]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(n²)", "O(n³)", "O(n log n)"], correct: 1, explanation: "Sort O(n log n), 2 loops O(n²)" }]
  },
  {
    id: 45,
    level: 5,
    title: "Minimum Window Substring",
    story: "Tìm đoạn ngắn nhất chứa tất cả ký tự cần thiết.",
    description: "Shortest substring chứa tất cả chars của t",
    skill: "Sliding Window",
    difficulty: "Hard",
    input: "Strings s và t",
    output: "Minimum window",
    examples: [{ input: 's = "ADOBECODEBANC", t = "ABC"', output: '"BANC"' }],
    hints: ["Sliding window với 2 pointers", "Map đếm chars cần và có"],
    interviewQuestions: ["Optimize với formed counter?"],
    testCases: [{ input: 's = "a", t = "aa"', output: '""' }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(n+m)", "O(nm)", "O(n²)"], correct: 1, explanation: "Mỗi char xử lý tối đa 2 lần (expand/contract)" }]
  },
  {
    id: 46,
    level: 5,
    title: "Decode Ways",
    story: "Đếm số cách decode tin nhắn mã hóa (A=1, B=2,...).",
    description: "Số cách decode string số",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "String s chứa digits",
    output: "Số cách decode",
    examples: [{ input: '"12"', output: "2", explanation: "'AB' hoặc 'L'" }],
    hints: ["dp[i] = dp[i-1] + dp[i-2] nếu valid"],
    interviewQuestions: ["Xử lý '0' như thế nào?", "Edge cases?"],
    testCases: [{ input: '"226"', output: "3" }],
    theoryQuestions: [{ question: "Giống bài nào?", options: ["Two Sum", "Climbing Stairs", "Coin Change", "LIS"], correct: 1, explanation: "Tương tự Fibonacci pattern" }]
  },
  {
    id: 47,
    level: 5,
    title: "Word Break",
    story: "Kiểm tra xem chuỗi có thể tách thành các từ trong dictionary không.",
    description: "Có thể segment string thành dictionary words không",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "String s và wordDict",
    output: "true/false",
    examples: [{ input: 's = "leetcode", wordDict = ["leet","code"]', output: "true" }],
    hints: ["dp[i] = true nếu s[0:i] có thể segment"],
    interviewQuestions: ["BFS approach?", "Trie optimization?"],
    testCases: [{ input: 's = "applepenapple", wordDict = ["apple","pen"]', output: "true" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(n²)", "O(n³)", "O(n*m)"], correct: 2, explanation: "n² loops, mỗi lần check O(n) string" }]
  },
  {
    id: 48,
    level: 5,
    title: "Unique Paths",
    story: "Đếm số đường đi từ góc trái-trên đến góc phải-dưới của grid.",
    description: "Số unique paths trong m×n grid (chỉ đi phải/xuống)",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "m và n",
    output: "Số đường đi",
    examples: [{ input: "m = 3, n = 7", output: "28" }],
    hints: ["dp[i][j] = dp[i-1][j] + dp[i][j-1]"],
    interviewQuestions: ["Space optimize O(n)?", "Công thức tổ hợp?"],
    testCases: [{ input: "m = 3, n = 2", output: "3" }],
    theoryQuestions: [{ question: "Công thức tổ hợp?", options: ["C(m,n)", "C(m+n, m)", "C(m+n-2, m-1)", "m*n"], correct: 2, explanation: "Chọn m-1 bước xuống trong m+n-2 bước" }]
  },
  {
    id: 49,
    level: 5,
    title: "Jump Game",
    story: "Kiểm tra có thể nhảy đến cuối mảng không.",
    description: "Có thể reach index cuối từ index 0 không",
    skill: "Greedy",
    difficulty: "Medium",
    input: "Mảng nums (max jump từ mỗi vị trí)",
    output: "true/false",
    examples: [{ input: "[2,3,1,1,4]", output: "true" }, { input: "[3,2,1,0,4]", output: "false" }],
    hints: ["Track maxReach", "Nếu i > maxReach thì false"],
    interviewQuestions: ["Greedy vs DP?", "Time complexity?"],
    testCases: [{ input: "[0]", output: "true" }],
    theoryQuestions: [{ question: "Greedy solution có complexity?", options: ["O(n²)", "O(n log n)", "O(n)", "O(1)"], correct: 2, explanation: "Duyệt một lần" }]
  },
  {
    id: 50,
    level: 5,
    title: "Rotate Image",
    story: "Xoay ảnh 90 độ cho app photo editor.",
    description: "Xoay matrix n×n 90 độ theo chiều kim đồng hồ",
    skill: "Matrix",
    difficulty: "Medium",
    input: "Matrix n×n",
    output: "Matrix đã xoay (in-place)",
    examples: [{ input: "[[1,2,3],[4,5,6],[7,8,9]]", output: "[[7,4,1],[8,5,2],[9,6,3]]" }],
    hints: ["Transpose rồi reverse mỗi row", "Hoặc rotate từng layer"],
    interviewQuestions: ["Xoay 180, 270 độ?", "In-place?"],
    testCases: [{ input: "[[1,2],[3,4]]", output: "[[3,1],[4,2]]" }],
    theoryQuestions: [{ question: "Transpose + reverse = rotate?", options: ["90 CW", "90 CCW", "180", "270"], correct: 0, explanation: "Transpose swap(i,j), reverse flip columns" }]
  },

  // ===== LEVEL 6: MEDIUM+ - Graph & Advanced =====
  {
    id: 51,
    level: 6,
    title: "Number of Islands",
    story: "Đếm số đảo trên bản đồ grid (1 = đất, 0 = nước).",
    description: "Đếm số islands trong grid",
    skill: "Graph",
    difficulty: "Medium",
    input: "Grid 2D chứa '1' và '0'",
    output: "Số đảo",
    examples: [{ input: '[["1","1","0"],["1","1","0"],["0","0","1"]]', output: "2" }],
    hints: ["DFS/BFS từ mỗi '1' chưa visited", "Mark visited bằng cách đổi thành '0'"],
    interviewQuestions: ["Union-Find approach?", "Không modify input?"],
    testCases: [{ input: '[["1","0"],["0","1"]]', output: "2" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(mn)", "O(m+n)", "O(mn²)"], correct: 1, explanation: "Visit mỗi cell tối đa một lần" }]
  },
  {
    id: 52,
    level: 6,
    title: "Clone Graph",
    story: "Deep copy một mạng xã hội (graph của friends).",
    description: "Deep clone undirected graph",
    skill: "Graph",
    difficulty: "Medium",
    input: "Node của graph",
    output: "Clone của graph",
    examples: [{ input: "[[2,4],[1,3],[2,4],[1,3]]", output: "Clone with same structure" }],
    hints: ["Map old node -> new node", "DFS/BFS traverse"],
    interviewQuestions: ["Xử lý cycles như thế nào?"],
    testCases: [{ input: "[[]]", output: "[[]]" }],
    theoryQuestions: [{ question: "Map dùng để?", options: ["Tối ưu time", "Tránh cycle vô hạn", "Đếm nodes", "Sort nodes"], correct: 1, explanation: "Check đã clone node này chưa" }]
  },
  {
    id: 53,
    level: 6,
    title: "Course Schedule",
    story: "Kiểm tra có thể hoàn thành tất cả courses (có prerequisites) không.",
    description: "Có thể finish tất cả courses không (detect cycle)",
    skill: "Graph",
    difficulty: "Medium",
    input: "numCourses và prerequisites",
    output: "true/false",
    examples: [{ input: "numCourses = 2, prerequisites = [[1,0]]", output: "true" }],
    hints: ["Topological sort", "Detect cycle trong directed graph"],
    interviewQuestions: ["Kahn's vs DFS?", "Cycle detection?"],
    testCases: [{ input: "numCourses = 2, prerequisites = [[1,0],[0,1]]", output: "false" }],
    theoryQuestions: [{ question: "Graph có cycle thì?", options: ["Có thể topo sort", "Không thể topo sort", "Tùy trường hợp", "Không liên quan"], correct: 1, explanation: "Cycle = không có valid ordering" }]
  },
  {
    id: 54,
    level: 6,
    title: "Pacific Atlantic Water Flow",
    story: "Tìm cells mà nước có thể chảy đến cả 2 đại dương.",
    description: "Cells có thể reach cả Pacific và Atlantic",
    skill: "Graph",
    difficulty: "Medium",
    input: "Matrix heights",
    output: "List cells",
    examples: [{ input: "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]", output: "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]" }],
    hints: ["BFS/DFS từ edges", "Intersection của 2 sets"],
    interviewQuestions: ["Tại sao đi từ ocean vào?"],
    testCases: [{ input: "[[1]]", output: "[[0,0]]" }],
    theoryQuestions: [{ question: "Reverse thinking giúp?", options: ["Giảm time", "Đơn giản hóa logic", "Giảm space", "Không giúp gì"], correct: 1, explanation: "Dễ hơn check từ mỗi cell đến 2 ocean" }]
  },
  {
    id: 55,
    level: 6,
    title: "Longest Consecutive Sequence",
    story: "Tìm dãy số liên tiếp dài nhất trong set.",
    description: "Length of longest consecutive sequence",
    skill: "Hash Table",
    difficulty: "Medium",
    input: "Unsorted array nums",
    output: "Length of longest consecutive",
    examples: [{ input: "[100,4,200,1,3,2]", output: "4", explanation: "[1,2,3,4]" }],
    hints: ["Set cho O(1) lookup", "Chỉ bắt đầu count khi num-1 không có trong set"],
    interviewQuestions: ["Tại sao O(n)?", "Union-Find approach?"],
    testCases: [{ input: "[0,3,7,2,5,8,4,6,0,1]", output: "9" }],
    theoryQuestions: [{ question: "Tại sao là O(n) không phải O(n²)?", options: ["Dùng hash", "Mỗi số chỉ visit 1 lần", "Sort trước", "Skip logic"], correct: 1, explanation: "Chỉ count từ start của sequence" }]
  },
  {
    id: 56,
    level: 6,
    title: "Alien Dictionary",
    story: "Suy ra thứ tự alphabet từ danh sách từ đã sort theo alien language.",
    description: "Tìm thứ tự chữ cái từ sorted dictionary",
    skill: "Graph",
    difficulty: "Hard",
    input: "List of words sorted lexicographically",
    output: "Order of characters",
    examples: [{ input: '["wrt","wrf","er","ett","rftt"]', output: '"wertf"' }],
    hints: ["Build graph từ adjacent words", "Topological sort"],
    interviewQuestions: ["Invalid input detection?", "Multiple valid orders?"],
    testCases: [{ input: '["z","x"]', output: '"zx"' }],
    theoryQuestions: [{ question: "Khi nào invalid?", options: ["Có cycle", "Word dài hơn đứng trước", "Cả hai", "Không bao giờ"], correct: 2, explanation: "Cả cycle và prefix issue đều invalid" }]
  },
  {
    id: 57,
    level: 6,
    title: "Graph Valid Tree",
    story: "Kiểm tra graph có phải tree hợp lệ không.",
    description: "Check if graph is valid tree",
    skill: "Graph",
    difficulty: "Medium",
    input: "n nodes và edges",
    output: "true nếu là tree",
    examples: [{ input: "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]", output: "true" }],
    hints: ["Tree = connected + no cycle + n-1 edges"],
    interviewQuestions: ["Union-Find vs DFS?"],
    testCases: [{ input: "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]", output: "false" }],
    theoryQuestions: [{ question: "Tree với n nodes có bao nhiêu edges?", options: ["n", "n-1", "n+1", "2n"], correct: 1, explanation: "Đúng n-1 edges cho tree" }]
  },
  {
    id: 58,
    level: 6,
    title: "Walls and Gates",
    story: "Tìm khoảng cách từ mỗi empty room đến gate gần nhất.",
    description: "Fill matrix với distance to nearest gate",
    skill: "Graph",
    difficulty: "Medium",
    input: "Matrix với INF, 0 (gate), -1 (wall)",
    output: "Matrix với distances",
    examples: [{ input: "[[INF,-1,0,INF],[INF,INF,INF,-1],[INF,-1,INF,-1],[0,-1,INF,INF]]", output: "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]" }],
    hints: ["Multi-source BFS từ tất cả gates"],
    interviewQuestions: ["Tại sao BFS từ gates?"],
    testCases: [{ input: "[[0]]", output: "[[0]]" }],
    theoryQuestions: [{ question: "Multi-source BFS có advantage?", options: ["Simpler code", "O(mn) thay vì O((mn)²)", "Cả hai", "Không có"], correct: 2, explanation: "Process tất cả sources cùng lúc" }]
  },
  {
    id: 59,
    level: 6,
    title: "Rotting Oranges",
    story: "Tính thời gian để tất cả cam tươi bị thối.",
    description: "Minutes until all oranges rot",
    skill: "Graph",
    difficulty: "Medium",
    input: "Grid 0=empty, 1=fresh, 2=rotten",
    output: "Minutes hoặc -1",
    examples: [{ input: "[[2,1,1],[1,1,0],[0,1,1]]", output: "4" }],
    hints: ["Multi-source BFS từ rotten oranges"],
    interviewQuestions: ["Tại sao BFS không DFS?"],
    testCases: [{ input: "[[2,1,1],[0,1,1],[1,0,1]]", output: "-1" }],
    theoryQuestions: [{ question: "BFS phù hợp cho?", options: ["Shortest path unweighted", "Shortest path weighted", "Longest path", "Any path"], correct: 0, explanation: "BFS đảm bảo shortest cho unweighted" }]
  },
  {
    id: 60,
    level: 6,
    title: "Word Search",
    story: "Tìm từ trong grid chữ cái (game word puzzle).",
    description: "Tìm word trong grid (di chuyển 4 hướng)",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "Grid và word",
    output: "true/false",
    examples: [{ input: 'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"', output: "true" }],
    hints: ["DFS + backtracking", "Mark visited, unmark khi backtrack"],
    interviewQuestions: ["Time complexity?", "Optimize với Trie?"],
    testCases: [{ input: 'word = "SEE"', output: "true" }],
    theoryQuestions: [{ question: "Time complexity worst case?", options: ["O(mn)", "O(mn * 4^L)", "O(mn * L)", "O(4^L)"], correct: 1, explanation: "mn starting points, 4^L paths mỗi điểm" }]
  },

  // ===== LEVEL 7: HARD - Advanced DP & Trees =====
  {
    id: 61,
    level: 7,
    title: "Validate BST",
    story: "Kiểm tra cây có phải Binary Search Tree hợp lệ không.",
    description: "Validate Binary Search Tree",
    skill: "Tree",
    difficulty: "Medium",
    input: "Root của tree",
    output: "true nếu valid BST",
    examples: [{ input: "[5,1,4,null,null,3,6]", output: "false", explanation: "4 > 5 nhưng ở right subtree của 5" }],
    hints: ["Inorder traversal phải tăng dần", "Hoặc check range cho mỗi node"],
    interviewQuestions: ["Inorder vs range checking?", "Handle duplicates?"],
    testCases: [{ input: "[2,1,3]", output: "true" }],
    theoryQuestions: [{ question: "BST property là?", options: ["Left < Root < Right", "Left < Root, Right > Root (cả subtree)", "Root ở giữa", "Balanced tree"], correct: 1, explanation: "Toàn bộ left subtree < root < toàn bộ right subtree" }]
  },
  {
    id: 62,
    level: 7,
    title: "Lowest Common Ancestor BST",
    story: "Tìm tổ tiên chung gần nhất của 2 nodes trong BST.",
    description: "LCA của 2 nodes trong BST",
    skill: "Tree",
    difficulty: "Medium",
    input: "Root, p, q",
    output: "LCA node",
    examples: [{ input: "root = [6,2,8,0,4,7,9], p = 2, q = 8", output: "6" }],
    hints: ["BST property: so sánh values để biết đi trái/phải"],
    interviewQuestions: ["Khác gì với binary tree thường?"],
    testCases: [{ input: "p = 2, q = 4", output: "2" }],
    theoryQuestions: [{ question: "BST LCA có complexity?", options: ["O(n)", "O(h)", "O(log n)", "O(1)"], correct: 1, explanation: "Đi theo 1 path, worst O(n), balanced O(log n)" }]
  },
  {
    id: 63,
    level: 7,
    title: "Kth Smallest in BST",
    story: "Tìm phần tử nhỏ thứ k trong BST.",
    description: "Kth smallest element in BST",
    skill: "Tree",
    difficulty: "Medium",
    input: "Root và k",
    output: "Kth smallest value",
    examples: [{ input: "root = [3,1,4,null,2], k = 1", output: "1" }],
    hints: ["Inorder traversal", "Đếm đến k"],
    interviewQuestions: ["Follow-up: frequent calls?", "BST modified often?"],
    testCases: [{ input: "k = 3", output: "3" }],
    theoryQuestions: [{ question: "Nếu BST modified often, optimize bằng?", options: ["Balanced tree", "Store count in node", "Array", "Heap"], correct: 1, explanation: "Mỗi node lưu số nodes trong subtree" }]
  },
  {
    id: 64,
    level: 7,
    title: "Construct BST from Preorder",
    story: "Xây dựng lại BST từ preorder traversal.",
    description: "Construct BST from preorder traversal",
    skill: "Tree",
    difficulty: "Medium",
    input: "Preorder array",
    output: "Root của BST",
    examples: [{ input: "[8,5,1,7,10,12]", output: "[8,5,10,1,7,null,12]" }],
    hints: ["First element = root", "Dùng bound để xác định valid range"],
    interviewQuestions: ["O(n²) vs O(n)?"],
    testCases: [{ input: "[1]", output: "[1]" }],
    theoryQuestions: [{ question: "Preorder của BST đủ để reconstruct vì?", options: ["Có root first", "BST property unique", "Cả hai", "Không đủ"], correct: 2, explanation: "Root first + BST property xác định left/right" }]
  },
  {
    id: 65,
    level: 7,
    title: "Serialize and Deserialize Binary Tree",
    story: "Convert tree thành string và ngược lại để lưu/load.",
    description: "Serialize và deserialize binary tree",
    skill: "Tree",
    difficulty: "Hard",
    input: "Root",
    output: "String và khôi phục lại tree",
    examples: [{ input: "[1,2,3,null,null,4,5]", output: '"1,2,null,null,3,4,null,null,5,null,null"' }],
    hints: ["Preorder với null markers", "DFS serialize/deserialize"],
    interviewQuestions: ["BFS vs DFS approach?", "Optimize space?"],
    testCases: [{ input: "[]", output: '""' }],
    theoryQuestions: [{ question: "Tại sao cần null markers?", options: ["Đẹp code", "Xác định cấu trúc tree", "Tối ưu space", "Không cần"], correct: 1, explanation: "Không có null marker, không biết tree shape" }]
  },
  {
    id: 66,
    level: 7,
    title: "Binary Tree Maximum Path Sum",
    story: "Tìm path có tổng lớn nhất trong binary tree.",
    description: "Maximum path sum (path = bất kỳ nodes liên tiếp)",
    skill: "Tree",
    difficulty: "Hard",
    input: "Root",
    output: "Maximum sum",
    examples: [{ input: "[-10,9,20,null,null,15,7]", output: "42", explanation: "15 + 20 + 7" }],
    hints: ["DFS return max one-sided path", "Update global max với path qua current node"],
    interviewQuestions: ["Tại sao cần 2 variables?", "Negative values?"],
    testCases: [{ input: "[1,2,3]", output: "6" }],
    theoryQuestions: [{ question: "Path có thể?", options: ["Chỉ đi xuống", "Qua root", "Bất kỳ liên tiếp", "Chỉ leaves"], correct: 2, explanation: "Path giữa bất kỳ 2 nodes" }]
  },
  {
    id: 67,
    level: 7,
    title: "Edit Distance",
    story: "Tính số operations tối thiểu để biến word1 thành word2.",
    description: "Minimum edit distance (insert/delete/replace)",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Hai strings word1 và word2",
    output: "Minimum operations",
    examples: [{ input: 'word1 = "horse", word2 = "ros"', output: "3" }],
    hints: ["dp[i][j] = min edits cho word1[0:i] -> word2[0:j]"],
    interviewQuestions: ["Recurrence relation?", "Space optimize?"],
    testCases: [{ input: 'word1 = "intention", word2 = "execution"', output: "5" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(mn)", "O(m+n)", "O(n²)"], correct: 1, explanation: "2D DP table" }]
  },
  {
    id: 68,
    level: 7,
    title: "Longest Common Subsequence",
    story: "Tìm subsequence chung dài nhất của 2 chuỗi.",
    description: "Length of LCS",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Hai strings",
    output: "Length of LCS",
    examples: [{ input: 'text1 = "abcde", text2 = "ace"', output: "3", explanation: '"ace"' }],
    hints: ["dp[i][j] = LCS của text1[0:i] và text2[0:j]"],
    interviewQuestions: ["Reconstruct LCS?", "Space O(n)?"],
    testCases: [{ input: 'text1 = "abc", text2 = "def"', output: "0" }],
    theoryQuestions: [{ question: "Khi chars match, dp[i][j] = ?", options: ["dp[i-1][j-1]", "dp[i-1][j-1] + 1", "max(dp[i-1][j], dp[i][j-1])", "1"], correct: 1, explanation: "Extend LCS by 1" }]
  },
  {
    id: 69,
    level: 7,
    title: "Partition Equal Subset Sum",
    story: "Chia mảng thành 2 phần có tổng bằng nhau.",
    description: "Có thể partition thành 2 equal sum subsets không",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums",
    output: "true/false",
    examples: [{ input: "[1,5,11,5]", output: "true", explanation: "[1,5,5] và [11]" }],
    hints: ["Tổng phải chẵn", "0/1 Knapsack: có thể đạt sum/2 không?"],
    interviewQuestions: ["Bitset optimization?"],
    testCases: [{ input: "[1,2,3,5]", output: "false" }],
    theoryQuestions: [{ question: "Bài này reduce thành?", options: ["Coin Change", "0/1 Knapsack", "LIS", "LCS"], correct: 1, explanation: "Subset sum = 0/1 Knapsack variant" }]
  },
  {
    id: 70,
    level: 7,
    title: "Target Sum",
    story: "Đếm số cách gán +/- cho mỗi số để đạt target.",
    description: "Ways to assign +/- to reach target",
    skill: "Dynamic Programming",
    difficulty: "Medium",
    input: "Mảng nums và target",
    output: "Number of ways",
    examples: [{ input: "nums = [1,1,1,1,1], target = 3", output: "5" }],
    hints: ["Transform thành subset sum problem"],
    interviewQuestions: ["Memoization vs tabulation?"],
    testCases: [{ input: "nums = [1], target = 1", output: "1" }],
    theoryQuestions: [{ question: "Transform: P - N = target, P + N = sum. P = ?", options: ["(sum+target)/2", "(sum-target)/2", "sum/2", "target/2"], correct: 0, explanation: "Tìm subset với sum = (sum+target)/2" }]
  },

  // ===== LEVEL 8: HARD - Heap & Intervals =====
  {
    id: 71,
    level: 8,
    title: "Merge Intervals",
    story: "Gộp các khoảng thời gian meeting bị overlap.",
    description: "Merge overlapping intervals",
    skill: "Intervals",
    difficulty: "Medium",
    input: "Array of intervals",
    output: "Merged intervals",
    examples: [{ input: "[[1,3],[2,6],[8,10],[15,18]]", output: "[[1,6],[8,10],[15,18]]" }],
    hints: ["Sort by start", "Merge nếu overlap"],
    interviewQuestions: ["Khi nào 2 intervals overlap?"],
    testCases: [{ input: "[[1,4],[4,5]]", output: "[[1,5]]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n)", "O(n log n)", "O(n²)", "O(log n)"], correct: 1, explanation: "Sort dominates" }]
  },
  {
    id: 72,
    level: 8,
    title: "Insert Interval",
    story: "Chèn interval mới và merge nếu cần.",
    description: "Insert new interval into sorted list",
    skill: "Intervals",
    difficulty: "Medium",
    input: "Sorted intervals và newInterval",
    output: "Merged result",
    examples: [{ input: "intervals = [[1,3],[6,9]], newInterval = [2,5]", output: "[[1,5],[6,9]]" }],
    hints: ["Add non-overlapping before", "Merge overlapping", "Add non-overlapping after"],
    interviewQuestions: ["In-place có được không?"],
    testCases: [{ input: "intervals = [], newInterval = [5,7]", output: "[[5,7]]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], correct: 2, explanation: "Traverse once" }]
  },
  {
    id: 73,
    level: 8,
    title: "Non-overlapping Intervals",
    story: "Xóa ít interval nhất để không còn overlap.",
    description: "Minimum removals to make non-overlapping",
    skill: "Intervals",
    difficulty: "Medium",
    input: "Array of intervals",
    output: "Minimum removals",
    examples: [{ input: "[[1,2],[2,3],[3,4],[1,3]]", output: "1", explanation: "Remove [1,3]" }],
    hints: ["Sort by end", "Greedy: keep interval với end sớm nhất"],
    interviewQuestions: ["Tại sao sort by end?"],
    testCases: [{ input: "[[1,2],[1,2],[1,2]]", output: "2" }],
    theoryQuestions: [{ question: "Greedy choice?", options: ["Keep max intervals", "Remove max overlap", "Keep earliest end", "Remove largest"], correct: 2, explanation: "Earliest end để lại nhiều space nhất" }]
  },
  {
    id: 74,
    level: 8,
    title: "Meeting Rooms II",
    story: "Tính số phòng họp tối thiểu cần thiết.",
    description: "Minimum meeting rooms required",
    skill: "Intervals",
    difficulty: "Medium",
    input: "Array of meeting times",
    output: "Minimum rooms",
    examples: [{ input: "[[0,30],[5,10],[15,20]]", output: "2" }],
    hints: ["Min heap track end times", "Hoặc sweep line với sorted events"],
    interviewQuestions: ["Heap vs sweep line?"],
    testCases: [{ input: "[[7,10],[2,4]]", output: "1" }],
    theoryQuestions: [{ question: "Sweep line tracks?", options: ["Start = +1, End = -1", "Intervals", "Rooms", "People"], correct: 0, explanation: "Count active meetings at each point" }]
  },
  {
    id: 75,
    level: 8,
    title: "Top K Frequent Elements",
    story: "Tìm k elements xuất hiện nhiều nhất.",
    description: "K most frequent elements",
    skill: "Heap",
    difficulty: "Medium",
    input: "Array nums và k",
    output: "K frequent elements",
    examples: [{ input: "nums = [1,1,1,2,2,3], k = 2", output: "[1,2]" }],
    hints: ["Count frequency", "Min heap size k hoặc bucket sort"],
    interviewQuestions: ["Heap vs bucket sort complexity?"],
    testCases: [{ input: "nums = [1], k = 1", output: "[1]" }],
    theoryQuestions: [{ question: "Bucket sort approach có complexity?", options: ["O(n log k)", "O(n)", "O(n log n)", "O(k log n)"], correct: 1, explanation: "Bucket index = frequency" }]
  },
  {
    id: 76,
    level: 8,
    title: "Find Median from Data Stream",
    story: "Maintain median khi data stream vào liên tục.",
    description: "Design class để addNum và findMedian",
    skill: "Heap",
    difficulty: "Hard",
    input: "Stream of numbers",
    output: "Median after each add",
    examples: [{ input: "addNum(1), addNum(2), findMedian()", output: "1.5" }],
    hints: ["Max heap cho nửa nhỏ, min heap cho nửa lớn", "Balance 2 heaps"],
    interviewQuestions: ["Tại sao 2 heaps?", "Follow-up optimizations?"],
    testCases: [{ input: "addNum(3), findMedian()", output: "2" }],
    theoryQuestions: [{ question: "Time per operation?", options: ["O(1)", "O(log n)", "O(n)", "O(n log n)"], correct: 1, explanation: "Heap insert O(log n)" }]
  },
  {
    id: 77,
    level: 8,
    title: "Kth Largest Element",
    story: "Tìm phần tử lớn thứ k trong array.",
    description: "Kth largest element",
    skill: "Heap",
    difficulty: "Medium",
    input: "Array và k",
    output: "Kth largest",
    examples: [{ input: "nums = [3,2,1,5,6,4], k = 2", output: "5" }],
    hints: ["Min heap size k", "QuickSelect O(n) average"],
    interviewQuestions: ["Heap vs QuickSelect trade-offs?"],
    testCases: [{ input: "nums = [3,2,3,1,2,4,5,5,6], k = 4", output: "4" }],
    theoryQuestions: [{ question: "QuickSelect worst case?", options: ["O(n)", "O(n log n)", "O(n²)", "O(k)"], correct: 2, explanation: "Bad pivot choices" }]
  },
  {
    id: 78,
    level: 8,
    title: "Task Scheduler",
    story: "Schedule tasks với cooldown time giữa same tasks.",
    description: "Minimum time to finish all tasks với cooldown n",
    skill: "Heap",
    difficulty: "Medium",
    input: "Tasks array và cooldown n",
    output: "Minimum intervals",
    examples: [{ input: 'tasks = ["A","A","A","B","B","B"], n = 2', output: "8" }],
    hints: ["Most frequent task determines min time", "Formula hoặc simulation"],
    interviewQuestions: ["Math formula approach?"],
    testCases: [{ input: 'tasks = ["A","A","A","B","B","B"], n = 0', output: "6" }],
    theoryQuestions: [{ question: "Key insight?", options: ["Sort tasks", "Count frequencies", "Most frequent needs most slots", "Random scheduling"], correct: 2, explanation: "Max freq task creates framework" }]
  },
  {
    id: 79,
    level: 8,
    title: "Reorganize String",
    story: "Sắp xếp lại string sao cho không có 2 ký tự giống nhau liền kề.",
    description: "Reorganize so no adjacent chars are same",
    skill: "Heap",
    difficulty: "Medium",
    input: "String s",
    output: "Reorganized string hoặc ''",
    examples: [{ input: '"aab"', output: '"aba"' }],
    hints: ["Max heap by frequency", "Alternate most frequent chars"],
    interviewQuestions: ["Khi nào impossible?"],
    testCases: [{ input: '"aaab"', output: '""' }],
    theoryQuestions: [{ question: "Impossible khi?", options: ["Any char > n/2", "Most frequent > (n+1)/2", "Odd length", "Even frequencies"], correct: 1, explanation: "Không đủ slots để alternate" }]
  },
  {
    id: 80,
    level: 8,
    title: "Sliding Window Maximum",
    story: "Tìm max trong mỗi sliding window size k.",
    description: "Maximum in each sliding window",
    skill: "Heap",
    difficulty: "Hard",
    input: "Array và window size k",
    output: "Array of maximums",
    examples: [{ input: "nums = [1,3,-1,-3,5,3,6,7], k = 3", output: "[3,3,5,5,6,7]" }],
    hints: ["Monotonic deque", "Deque stores indices của potential max"],
    interviewQuestions: ["Tại sao deque không heap?"],
    testCases: [{ input: "nums = [1], k = 1", output: "[1]" }],
    theoryQuestions: [{ question: "Monotonic deque có time?", options: ["O(nk)", "O(n log k)", "O(n)", "O(k)"], correct: 2, explanation: "Mỗi element enqueue/dequeue tối đa 1 lần" }]
  },

  // ===== LEVEL 9: HARD - Backtracking & Trie =====
  {
    id: 81,
    level: 9,
    title: "Subsets",
    story: "Generate tất cả subsets của array.",
    description: "All possible subsets",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "Distinct integers array",
    output: "All subsets",
    examples: [{ input: "[1,2,3]", output: "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]" }],
    hints: ["Backtracking với include/exclude", "Hoặc bit manipulation"],
    interviewQuestions: ["Bao nhiêu subsets?", "Có duplicates thì sao?"],
    testCases: [{ input: "[0]", output: "[[],[0]]" }],
    theoryQuestions: [{ question: "Số subsets của n elements?", options: ["n", "n!", "2^n", "n²"], correct: 2, explanation: "Mỗi element có 2 choices" }]
  },
  {
    id: 82,
    level: 9,
    title: "Permutations",
    story: "Generate tất cả hoán vị của array.",
    description: "All permutations",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "Distinct integers",
    output: "All permutations",
    examples: [{ input: "[1,2,3]", output: "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]" }],
    hints: ["Swap elements", "Track used elements"],
    interviewQuestions: ["Số permutations?", "Có duplicates?"],
    testCases: [{ input: "[1]", output: "[[1]]" }],
    theoryQuestions: [{ question: "Số permutations của n elements?", options: ["2^n", "n²", "n!", "n"], correct: 2, explanation: "n choices cho vị trí 1, n-1 cho vị trí 2,..." }]
  },
  {
    id: 83,
    level: 9,
    title: "Combination Sum",
    story: "Tìm các combinations có tổng bằng target (có thể reuse).",
    description: "Combinations that sum to target",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "Candidates và target",
    output: "All combinations",
    examples: [{ input: "candidates = [2,3,6,7], target = 7", output: "[[2,2,3],[7]]" }],
    hints: ["Backtracking", "Start từ current index (cho phép reuse)"],
    interviewQuestions: ["Có vs không cho phép reuse?"],
    testCases: [{ input: "candidates = [2], target = 1", output: "[]" }],
    theoryQuestions: [{ question: "Khác Combination Sum II ở đâu?", options: ["Target", "Duplicates", "Reuse allowed", "Order matters"], correct: 2, explanation: "Sum II không cho reuse" }]
  },
  {
    id: 84,
    level: 9,
    title: "Letter Combinations of Phone",
    story: "Mapping số điện thoại thành chữ cái (T9 keyboard).",
    description: "Letter combinations từ phone digits",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "Digit string",
    output: "All letter combinations",
    examples: [{ input: '"23"', output: '["ad","ae","af","bd","be","bf","cd","ce","cf"]' }],
    hints: ["Map mỗi digit -> letters", "Backtracking build combinations"],
    interviewQuestions: ["Iterative approach?"],
    testCases: [{ input: '""', output: "[]" }],
    theoryQuestions: [{ question: "Số combinations cho n digits?", options: ["3^n", "4^n", "3^n to 4^n", "2^n"], correct: 2, explanation: "Mỗi digit map 3-4 letters" }]
  },
  {
    id: 85,
    level: 9,
    title: "N-Queens",
    story: "Đặt N quân hậu trên bàn cờ NxN sao cho không đe dọa nhau.",
    description: "N-Queens puzzle solutions",
    skill: "Backtracking",
    difficulty: "Hard",
    input: "n",
    output: "All valid board configurations",
    examples: [{ input: "n = 4", output: "[['.Q..','...Q','Q...','..Q.'],['..Q.','Q...','...Q','.Q..']]" }],
    hints: ["Place queen per row", "Track columns, diagonals"],
    interviewQuestions: ["Optimize với bit manipulation?"],
    testCases: [{ input: "n = 1", output: "[['Q']]" }],
    theoryQuestions: [{ question: "Time complexity?", options: ["O(n!)", "O(n²)", "O(2^n)", "O(n^n)"], correct: 0, explanation: "n choices cho row 1, n-1 cho row 2,..." }]
  },
  {
    id: 86,
    level: 9,
    title: "Sudoku Solver",
    story: "Giải Sudoku puzzle.",
    description: "Solve Sudoku puzzle",
    skill: "Backtracking",
    difficulty: "Hard",
    input: "9x9 board với '.' là empty",
    output: "Solved board",
    examples: [{ input: "Valid Sudoku puzzle", output: "Solved puzzle" }],
    hints: ["Try 1-9 cho mỗi empty cell", "Validate row, col, box"],
    interviewQuestions: ["Optimizations?", "Multiple solutions?"],
    testCases: [{ input: "Easy puzzle", output: "Unique solution" }],
    theoryQuestions: [{ question: "Constraint propagation giúp?", options: ["Reduce search space", "Guarantee solution", "Speed up validation", "All above"], correct: 3, explanation: "Prune impossible values sớm" }]
  },
  {
    id: 87,
    level: 9,
    title: "Implement Trie",
    story: "Implement prefix tree cho autocomplete.",
    description: "Implement Trie (insert, search, startsWith)",
    skill: "Trie",
    difficulty: "Medium",
    input: "Operations",
    output: "Results",
    examples: [{ input: "insert('apple'), search('apple'), startsWith('app')", output: "null, true, true" }],
    hints: ["Node với children map và isEnd flag"],
    interviewQuestions: ["Space complexity?", "Delete operation?"],
    testCases: [{ input: "search('app')", output: "false" }],
    theoryQuestions: [{ question: "Trie search time?", options: ["O(n)", "O(m)", "O(log n)", "O(1)"], correct: 1, explanation: "m = length of word" }]
  },
  {
    id: 88,
    level: 9,
    title: "Word Search II",
    story: "Tìm nhiều words trong grid cùng lúc.",
    description: "Find all words from dictionary in grid",
    skill: "Trie",
    difficulty: "Hard",
    input: "Grid và words list",
    output: "Found words",
    examples: [{ input: 'board, words = ["oath","pea","eat","rain"]', output: '["eat","oath"]' }],
    hints: ["Build Trie từ words", "DFS với Trie pruning"],
    interviewQuestions: ["Tại sao Trie tốt hơn?"],
    testCases: [{ input: "Single word", output: "Found or not" }],
    theoryQuestions: [{ question: "Trie giúp optimize từ?", options: ["O(words * mn * 4^L)", "Prune branches sớm", "Both", "Neither"], correct: 2, explanation: "Share prefix, prune invalid paths" }]
  },
  {
    id: 89,
    level: 9,
    title: "Design Add Search Words",
    story: "Tìm từ với wildcard '.' (match any char).",
    description: "Add word và search với '.' wildcard",
    skill: "Trie",
    difficulty: "Medium",
    input: "Operations",
    output: "Search results",
    examples: [{ input: "addWord('bad'), search('b.d')", output: "null, true" }],
    hints: ["Trie + DFS khi gặp '.'"],
    interviewQuestions: ["Time complexity với many '.'?"],
    testCases: [{ input: "search('..')", output: "Match any 2-char word" }],
    theoryQuestions: [{ question: "'.' wildcard cần?", options: ["Linear search", "DFS all children", "BFS", "Binary search"], correct: 1, explanation: "Try tất cả children" }]
  },
  {
    id: 90,
    level: 9,
    title: "Palindrome Partitioning",
    story: "Chia string thành các palindrome substrings.",
    description: "All ways to partition into palindromes",
    skill: "Backtracking",
    difficulty: "Medium",
    input: "String s",
    output: "All partitions",
    examples: [{ input: '"aab"', output: '[["a","a","b"],["aa","b"]]' }],
    hints: ["Backtracking", "Check palindrome cho mỗi prefix"],
    interviewQuestions: ["DP để precompute palindromes?"],
    testCases: [{ input: '"a"', output: '[["a"]]' }],
    theoryQuestions: [{ question: "Precompute palindromes có time?", options: ["O(n)", "O(n²)", "O(n³)", "O(2^n)"], correct: 1, explanation: "DP table n×n" }]
  },

  // ===== LEVEL 10: VERY HARD - Advanced Algorithms =====
  {
    id: 91,
    level: 10,
    title: "Trapping Rain Water",
    story: "Tính lượng nước mưa có thể chứa giữa các cột.",
    description: "Water trapped between bars",
    skill: "Two Pointers",
    difficulty: "Hard",
    input: "Height array",
    output: "Total water",
    examples: [{ input: "[0,1,0,2,1,0,1,3,2,1,2,1]", output: "6" }],
    hints: ["Two pointers từ 2 đầu", "Track leftMax và rightMax"],
    interviewQuestions: ["Stack approach?", "DP approach?"],
    testCases: [{ input: "[4,2,0,3,2,5]", output: "9" }],
    theoryQuestions: [{ question: "Water at position i = ?", options: ["leftMax - height[i]", "min(leftMax, rightMax) - height[i]", "rightMax - height[i]", "max - height[i]"], correct: 1, explanation: "Bị giới hạn bởi cột thấp hơn" }]
  },
  {
    id: 92,
    level: 10,
    title: "Longest Valid Parentheses",
    story: "Tìm đoạn ngoặc hợp lệ dài nhất.",
    description: "Length of longest valid parentheses substring",
    skill: "Dynamic Programming",
    difficulty: "Hard",
    input: "String chứa '(' và ')'",
    output: "Length",
    examples: [{ input: '")()())"', output: "4", explanation: '"()()"' }],
    hints: ["DP hoặc Stack", "Stack store indices"],
    interviewQuestions: ["DP vs Stack approach?"],
    testCases: [{ input: '"(()"', output: "2" }],
    theoryQuestions: [{ question: "Stack approach lưu gì?", options: ["Characters", "Indices", "Counts", "Pairs"], correct: 1, explanation: "Index của '(' và last unmatched ')'" }]
  },
  {
    id: 93,
    level: 10,
    title: "Regular Expression Matching",
    story: "Implement regex matching với '.' và '*'.",
    description: "Regex matching với '.' (any char) và '*' (zero or more)",
    skill: "Dynamic Programming",
    difficulty: "Hard",
    input: "String s và pattern p",
    output: "true nếu match",
    examples: [{ input: 's = "aa", p = "a*"', output: "true" }],
    hints: ["DP 2D", "Xử lý '*' cẩn thận"],
    interviewQuestions: ["Recursive với memoization?"],
    testCases: [{ input: 's = "ab", p = ".*"', output: "true" }],
    theoryQuestions: [{ question: "'*' có thể match?", options: ["1+ chars", "0+ chars", "Exactly 1", "Any"], correct: 1, explanation: "Zero or more of preceding element" }]
  },
  {
    id: 94,
    level: 10,
    title: "Wildcard Matching",
    story: "Pattern matching với '?' và '*'.",
    description: "Wildcard matching ('?' = any one, '*' = any sequence)",
    skill: "Dynamic Programming",
    difficulty: "Hard",
    input: "String s và pattern p",
    output: "true nếu match",
    examples: [{ input: 's = "adceb", p = "*a*b"', output: "true" }],
    hints: ["DP hoặc two pointers với backtracking"],
    interviewQuestions: ["Khác regex matching ở đâu?"],
    testCases: [{ input: 's = "acdcb", p = "a*c?b"', output: "false" }],
    theoryQuestions: [{ question: "Khác regex?", options: ["'*' meaning", "'?' meaning", "Both", "Same"], correct: 0, explanation: "'*' match any sequence, không cần preceding char" }]
  },
  {
    id: 95,
    level: 10,
    title: "Burst Balloons",
    story: "Max coins từ việc nổ bóng bay theo thứ tự tối ưu.",
    description: "Maximum coins khi burst balloons",
    skill: "Dynamic Programming",
    difficulty: "Hard",
    input: "Array nums (balloon values)",
    output: "Maximum coins",
    examples: [{ input: "[3,1,5,8]", output: "167" }],
    hints: ["Think về balloon cuối cùng burst trong range", "Interval DP"],
    interviewQuestions: ["Tại sao nghĩ ngược?"],
    testCases: [{ input: "[1,5]", output: "10" }],
    theoryQuestions: [{ question: "Subproblem definition?", options: ["First to burst", "Last to burst", "All at once", "Random"], correct: 1, explanation: "Last burst không ảnh hưởng neighbors" }]
  },
  {
    id: 96,
    level: 10,
    title: "Largest Rectangle in Histogram",
    story: "Tìm rectangle lớn nhất trong histogram.",
    description: "Largest rectangle area in histogram",
    skill: "Stack",
    difficulty: "Hard",
    input: "Heights array",
    output: "Maximum area",
    examples: [{ input: "[2,1,5,6,2,3]", output: "10" }],
    hints: ["Monotonic increasing stack", "Pop khi gặp bar thấp hơn"],
    interviewQuestions: ["Divide and conquer approach?"],
    testCases: [{ input: "[2,4]", output: "4" }],
    theoryQuestions: [{ question: "Stack lưu gì?", options: ["Heights", "Areas", "Indices", "Widths"], correct: 2, explanation: "Index để tính width" }]
  },
  {
    id: 97,
    level: 10,
    title: "Maximal Rectangle",
    story: "Tìm rectangle chứa toàn 1s lớn nhất trong matrix.",
    description: "Largest rectangle containing only 1s",
    skill: "Stack",
    difficulty: "Hard",
    input: "Binary matrix",
    output: "Maximum area",
    examples: [{ input: '[["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]', output: "6" }],
    hints: ["Convert thành histogram problem cho mỗi row"],
    interviewQuestions: ["DP approach?"],
    testCases: [{ input: '[["0"]]', output: "0" }],
    theoryQuestions: [{ question: "Reduce thành bài nào?", options: ["Number of Islands", "Largest Histogram", "Container Water", "Trapping Water"], correct: 1, explanation: "Mỗi row = histogram base" }]
  },
  {
    id: 98,
    level: 10,
    title: "Word Ladder",
    story: "Transform từ start word thành end word với mỗi bước đổi 1 ký tự.",
    description: "Shortest transformation sequence length",
    skill: "Graph",
    difficulty: "Hard",
    input: "beginWord, endWord, wordList",
    output: "Shortest sequence length",
    examples: [{ input: 'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]', output: "5" }],
    hints: ["BFS", "Generate tất cả possible next words"],
    interviewQuestions: ["Bidirectional BFS?", "Optimize neighbor finding?"],
    testCases: [{ input: "endWord not in list", output: "0" }],
    theoryQuestions: [{ question: "Bidirectional BFS giúp?", options: ["Giảm time O(b^d) thành O(b^(d/2))", "Giảm space", "Simpler code", "Nothing"], correct: 0, explanation: "Search từ 2 đầu gặp nhau ở giữa" }]
  },
  {
    id: 99,
    level: 10,
    title: "Minimum Window Containing All Elements",
    story: "Tìm window nhỏ nhất chứa tất cả elements distinct.",
    description: "Smallest subarray containing all unique elements",
    skill: "Sliding Window",
    difficulty: "Hard",
    input: "Array nums",
    output: "Minimum window size",
    examples: [{ input: "[1,2,1,3,4,2,3]", output: "4", explanation: "[1,3,4,2] hoặc [3,4,2,3]" }],
    hints: ["Count distinct elements", "Sliding window track frequencies"],
    interviewQuestions: ["Two pointer approach?"],
    testCases: [{ input: "[1,1,1]", output: "1" }],
    theoryQuestions: [{ question: "Khi nào shrink window?", options: ["Always", "Khi có đủ elements", "Khi thiếu element", "Never"], correct: 1, explanation: "Thử shrink khi đã có tất cả" }]
  },
  {
    id: 100,
    level: 10,
    title: "LRU Cache",
    story: "Implement Least Recently Used cache.",
    description: "Design LRU Cache với get và put O(1)",
    skill: "Design",
    difficulty: "Medium",
    input: "Capacity và operations",
    output: "Results",
    examples: [{ input: "LRUCache(2), put(1,1), put(2,2), get(1), put(3,3), get(2)", output: "null, null, null, 1, null, -1" }],
    hints: ["HashMap + Doubly Linked List", "HashMap cho O(1) lookup, DLL cho O(1) update order"],
    interviewQuestions: ["Tại sao cần doubly linked?", "Thread-safe?"],
    testCases: [{ input: "Capacity 1", output: "Evict immediately" }],
    theoryQuestions: [{ question: "DLL operations needed?", options: ["Add to head, remove any", "Add to tail, remove head", "Add/remove anywhere", "Only add"], correct: 0, explanation: "Move to head khi access, remove từ bất kỳ đâu" }]
  }
];

export const getRandomProblem = (maxLevel?: number): Problem => {
  const filtered = maxLevel ? problems.filter(p => p.level <= maxLevel) : problems;
  return filtered[Math.floor(Math.random() * filtered.length)];
};

export const getProblemById = (id: number): Problem | undefined => {
  return problems.find(p => p.id === id);
};

export const getProblemsByDifficulty = (difficulty: 'Easy' | 'Medium' | 'Hard'): Problem[] => {
  return problems.filter(p => p.difficulty === difficulty);
};

export const getProblemByDifficulty = (difficulty: 'Easy' | 'Medium' | 'Hard'): Problem | undefined => {
  const filtered = problems.filter(p => p.difficulty === difficulty);
  return filtered[Math.floor(Math.random() * filtered.length)];
};

export const getProblemsByLevel = (level: number): Problem[] => {
  return problems.filter(p => p.level === level);
};

export const getAllProblems = (): Problem[] => {
  return problems;
};
